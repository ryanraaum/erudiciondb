% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/interface.R
\name{.update_object}
\alias{.update_object}
\title{Update an object by creating and inserting a new revision}
\usage{
.update_object(connection, this_object, ...)
}
\arguments{
\item{connection}{Database connection (not pool - must support transactions)}

\item{this_object}{The current object to update (must exist in database)}

\item{...}{Named parameters with field updates (e.g., title = "New Title")}
}
\value{
UUID of the updated object (same as input object_id)
}
\description{
Complete update workflow: revise object, destage old revision, insert new revision.
All operations wrapped in a database transaction for atomicity.
}
\details{
This function implements the complete revision tracking workflow:
\enumerate{
\item Create revised object with \code{.revise_object()} (increments revision)
\item Start database transaction
\item \strong{CRITICAL:} Destage old revision FIRST (stage = -1) via \code{.destage_one()}
\item Insert new revision (stage = 0) via \code{.insert_one()}
\item Commit transaction (or rollback on error)
}

The transaction ensures atomicity - either both operations succeed or neither does.
}
\note{
\strong{CRITICAL ORDERING:} \code{.destage_one()} MUST be called BEFORE \code{.insert_one()}
to prevent a race condition where two revisions temporarily have stage=0
(active) simultaneously. This could lead to duplicate active revisions if the
transaction is interrupted between operations. The ordering ensures at most
one active revision exists at any point in time.
}
\keyword{internal}
